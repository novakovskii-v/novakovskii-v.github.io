<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STL Loader with Three.js</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>STL Loader Demo</h3>
        <p>Загруженный STL файл и конус</p>
        <p>Используйте мышь для вращения камеры</p>
        <div style="margin-top: 10px;">
            <input type="file" id="fileInput" accept=".stl" style="display: none;">
            <button onclick="document.getElementById('fileInput').click()" style="padding: 5px 10px; background: #007acc; color: white; border: none; border-radius: 3px; cursor: pointer;">Выбрать STL файл</button>
            <input type="text" id="urlInput" placeholder="Или введите URL STL файла" style="margin-left: 10px; padding: 5px; width: 300px;">
            <button onclick="loadFromUrl()" style="padding: 5px 10px; background: #28a745; color: white; border: none; border-radius: 3px; cursor: pointer; margin-left: 5px;">Загрузить по URL</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Инициализация сцены, камеры и рендерера
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Добавление OrbitControls для управления камерой
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Освещение
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Создание конуса
        const coneGeometry = new THREE.ConeGeometry(1, 2, 8);
        const coneMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x00ff00,
            transparent: true,
            opacity: 0.8
        });
        const cone = new THREE.Mesh(coneGeometry, coneMaterial);
        cone.position.set(-3, 0, 0);
        cone.castShadow = true;
        cone.receiveShadow = true;
        scene.add(cone);

        // STL файл будет загружен через интерфейс пользователя

        // Добавление плоскости для теней
        const planeGeometry = new THREE.PlaneGeometry(20, 20);
        const planeMaterial = new THREE.MeshPhongMaterial({ color: 0x444444 });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -2;
        plane.receiveShadow = true;
        scene.add(plane);

        // Анимация
        function animate() {
            requestAnimationFrame(animate);
            
            // Вращение конуса
            cone.rotation.y += 0.01;
            
            controls.update();
            renderer.render(scene, camera);
        }

        // Обработка изменения размера окна
        window.addEventListener('resize', onWindowResize, false);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        animate();

        // Функция загрузки STL по URL
        function loadFromUrl() {
            const url = document.getElementById('urlInput').value.trim();
            if (url) {
                loadSTLFile(url);
            } else {
                alert('Пожалуйста, введите URL STL файла');
            }
        }

        // Функция загрузки STL файла
        function loadSTLFile(url) {
            const loader = new THREE.STLLoader();
            loader.load(
                url,
                function (geometry) {
                    // Удаляем предыдущую STL модель, если есть
                    scene.children = scene.children.filter(child => 
                        child !== stlMesh && child !== cone && child !== plane
                    );
                    scene.add(cone);
                    scene.add(plane);

                    const material = new THREE.MeshPhongMaterial({ 
                        color: 0xff8800,
                        transparent: true,
                        opacity: 0.9
                    });
                    stlMesh = new THREE.Mesh(geometry, material);
                    
                    // Центрирование и масштабирование модели
                    geometry.computeBoundingBox();
                    const center = geometry.boundingBox.getCenter(new THREE.Vector3());
                    stlMesh.position.sub(center);
                    
                    // Масштабирование для лучшего отображения
                    const size = geometry.boundingBox.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 3 / maxDim;
                    stlMesh.scale.set(scale, scale, scale);
                    
                    stlMesh.position.set(3, 0, 0);
                    stlMesh.castShadow = true;
                    stlMesh.receiveShadow = true;
                    scene.add(stlMesh);
                },
                function (xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% загружено');
                },
                function (error) {
                    console.error('Ошибка загрузки STL файла:', error);
                    alert('Ошибка загрузки STL файла. Проверьте URL и попробуйте снова.');
                }
            );
        }

        // Обработчик выбора файла
        document.getElementById('fileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const loader = new THREE.STLLoader();
                    const geometry = loader.parse(e.target.result);
                    
                    // Удаляем предыдущую STL модель, если есть
                    scene.children = scene.children.filter(child => 
                        child !== stlMesh && child !== cone && child !== plane
                    );
                    scene.add(cone);
                    scene.add(plane);

                    const material = new THREE.MeshPhongMaterial({ 
                        color: 0xff8800,
                        transparent: true,
                        opacity: 0.9
                    });
                    stlMesh = new THREE.Mesh(geometry, material);
                    
                    // Центрирование и масштабирование модели
                    geometry.computeBoundingBox();
                    const center = geometry.boundingBox.getCenter(new THREE.Vector3());
                    stlMesh.position.sub(center);
                    
                    // Масштабирование для лучшего отображения
                    const size = geometry.boundingBox.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 3 / maxDim;
                    stlMesh.scale.set(scale, scale, scale);
                    
                    stlMesh.position.set(3, 0, 0);
                    stlMesh.castShadow = true;
                    stlMesh.receiveShadow = true;
                    scene.add(stlMesh);
                };
                reader.readAsArrayBuffer(file);
            }
        });

        // Глобальная переменная для STL меша
        let stlMesh = null;
    </script>
</body>
</html> 
